plugins {
    id 'java'
    id 'org.springframework.boot' version '3.4.0'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'jacoco'
    id 'com.bmuschko.docker-remote-api' version '9.4.0'
    id 'org.openapi.generator' version '7.7.0'
}

group = 'app.chatbot'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += "-parameters"
    options.release = 17
}

tasks.named('bootJar') {
    doFirst {
        delete fileTree(dir: "${buildDir}/libs", include: '*.jar')
    }
}

docker {
    url = System.getenv('DOCKER_HOST') ?: 'unix:///var/run/docker.sock'
}

repositories {
	mavenCentral()
}

import groovy.json.JsonOutput
import groovy.json.JsonSlurper

def litellmGeneratedDir = "$buildDir/generated/sources/litellm"
def litellmProcessedSpec = "$buildDir/generated/specs/litellm-openapi-processed.json"

sourceSets {
    main {
        java {
            srcDir "$litellmGeneratedDir/src/main/java"
        }
        resources {
            srcDir "$litellmGeneratedDir/src/main/resources"
        }
    }
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'  // For health checks and monitoring
    implementation 'org.flywaydb:flyway-core:11.3.0'  // Latest stable version compatible with PostgreSQL 16 and Spring Boot 3.4
    implementation 'org.flywaydb:flyway-database-postgresql:11.3.0'  // PostgreSQL-specific support for Flyway 11.x
    // Database drivers - H2 for dev/test, PostgreSQL for production
    runtimeOnly 'com.h2database:h2'
    runtimeOnly 'io.r2dbc:r2dbc-h2'
    runtimeOnly 'org.postgresql:r2dbc-postgresql:1.0.8.RELEASE'  // Spring Boot 3.4.11 compatible version
    runtimeOnly 'org.postgresql:postgresql:42.7.8' // Spring Boot 3.4.11 tested PostgreSQL driver version
    
    implementation 'org.openapitools:jackson-databind-nullable:0.2.6'
    implementation 'io.projectreactor.netty:reactor-netty-http'
    
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    testCompileOnly 'org.projectlombok:lombok'
    testAnnotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testImplementation 'org.seleniumhq.selenium:selenium-java:4.25.0'
    testImplementation 'io.github.bonigarcia:webdrivermanager:5.9.2'
    testImplementation 'org.awaitility:awaitility:4.2.1'
    testImplementation 'io.projectreactor:reactor-test'
    testImplementation 'com.squareup.okhttp3:mockwebserver:4.12.0'
    testImplementation 'io.cucumber:cucumber-java:7.16.1'
    testImplementation 'io.cucumber:cucumber-junit-platform-engine:7.16.1'
    testImplementation 'org.junit.platform:junit-platform-suite:1.10.3'
}

tasks.register('prepareLiteLlmSpec') {
    inputs.file("$projectDir/litellm-openapi.json")
    outputs.file(litellmProcessedSpec)
    doLast {
        def parser = new groovy.json.JsonSlurper()
        def json = parser.parse(new File("$projectDir/litellm-openapi.json"))
        if (!json.containsKey("\$defs")) {
            def proxyDefs = json?.components?.schemas?.ProxyChatCompletionRequest?.get("\$defs")
            if (proxyDefs instanceof Map) {
                json.put("\$defs", proxyDefs)
            }
        }

        def components = json?.components
        if (components instanceof Map) {
            def schemas = components.schemas
            if (schemas instanceof Map) {
                if (!(schemas.MCPCredentials instanceof Map)) {
                    schemas.MCPCredentials = [
                            type      : "object",
                            title     : "MCPCredentials",
                            properties: [
                                    auth_value   : [
                                            anyOf: [[type: "string"], [type: "null"]],
                                            title: "Auth Value"
                                    ],
                                    client_id    : [
                                            anyOf: [[type: "string"], [type: "null"]],
                                            title: "Client Id"
                                    ],
                                    client_secret: [
                                            anyOf: [[type: "string"], [type: "null"]],
                                            title: "Client Secret"
                                    ],
                                    scopes       : [
                                            anyOf: [[items: [type: "string"], type: "array"], [type: "null"]],
                                            title: "Scopes"
                                    ]
                            ]
                    ]
                }

                def ensureProperties = { Map schema ->
                    if (schema == null) {
                        return null
                    }
                    if (!(schema.properties instanceof Map)) {
                        schema.properties = [:]
                    }
                    return schema.properties
                }

                def addCredentialsProperty = { Map schema ->
                    def props = ensureProperties(schema)
                    if (props != null && !(props.credentials instanceof Map)) {
                        props.credentials = [
                                anyOf: [
                                        ["\$ref": "#/components/schemas/MCPCredentials"],
                                        [type: "null"]
                                ],
                                title: "Credentials"
                        ]
                    }
                }

                def addStaticHeadersProperty = { Map schema ->
                    def props = ensureProperties(schema)
                    if (props != null && !(props.static_headers instanceof Map)) {
                        props.static_headers = [
                                anyOf: [
                                        [
                                                type                : "object",
                                                additionalProperties: [type: "string"]
                                        ],
                                        [type: "null"]
                                ],
                                title: "Static Headers"
                        ]
                    }
                }

                addCredentialsProperty(schemas.NewMCPServerRequest as Map)
                addCredentialsProperty(schemas.UpdateMCPServerRequest as Map)
                addCredentialsProperty(schemas.LiteLLM_MCPServerTable as Map)

                addStaticHeadersProperty(schemas.NewMCPServerRequest as Map)
                addStaticHeadersProperty(schemas.UpdateMCPServerRequest as Map)
                addStaticHeadersProperty(schemas.LiteLLM_MCPServerTable as Map)
            }
        }
        def outputFile = new File(litellmProcessedSpec)
        outputFile.parentFile.mkdirs()
        outputFile.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(json))
    }
}

openApiGenerate {
    generatorName = "java"
    inputSpec = litellmProcessedSpec
    outputDir = litellmGeneratedDir
    apiPackage = "app.chatbot.litellm.api"
    invokerPackage = "app.chatbot.litellm"
    modelPackage = "app.chatbot.litellm.model"
    library = "webclient"
    globalProperties = [
            apis : "",
            models : "",
            supportingFiles: "ApiClient.java,ApiException.java,ApiResponse.java,Configuration.java,EncodingUtils.java,ServerConfiguration.java,ServerVariable.java,StringUtil.java,JavaTimeFormatter.java,RFC3339DateFormat.java,auth/Authentication.java,auth/ApiKeyAuth.java,auth/HttpBasicAuth.java,auth/HttpBearerAuth.java"
    ]
    configOptions = [
            dateLibrary: "java8",
            java8: "true",
            hideGenerationTimestamp: "true",
            useBeanValidation: "true",
            useJakartaEe: "true",
            useOas31: "true"
    ]
    skipValidateSpec = true
}

tasks.named('compileJava') {
    dependsOn tasks.named('openApiGenerate')
}

tasks.named('processResources') {
    dependsOn tasks.named('openApiGenerate')
}

tasks.named('openApiGenerate') {
    dependsOn tasks.named('prepareLiteLlmSpec')
    outputs.upToDateWhen { false }
    doFirst {
        project.delete(litellmGeneratedDir)
    }
    doLast {
        def apiDir = file("$litellmGeneratedDir/src/main/java/app/chatbot/litellm/api")
        if (apiDir.exists()) {
            apiDir.listFiles()?.each { file ->
                if (file.isFile() && file.name != "McpApi.java") {
                    file.delete()
                }
            }
        }
        def allowedModels = [
                "LiteLLMMCPServerTable.java",
                "LiteLLMMCPServerTableTeamsInnerValue.java",
                "MCPCredentials.java",
                "NewMCPServerRequest.java",
                "UpdateMCPServerRequest.java",
                "HTTPValidationError.java",
                "ValidationError.java",
                "ValidationErrorLocInner.java"
        ] as Set
        def modelDir = file("$litellmGeneratedDir/src/main/java/app/chatbot/litellm/model")
        if (modelDir.exists()) {
            modelDir.listFiles()?.each { file ->
                if (file.isFile() && !allowedModels.contains(file.name)) {
                    file.delete()
                }
            }
        }
        def authDir = file("$litellmGeneratedDir/src/main/java/app/chatbot/litellm/auth")
        authDir.mkdirs()
    }
}

tasks.named('test') {
    useJUnitPlatform()
    finalizedBy(tasks.named('jacocoTestReport'))
}

def coverageIncludes = [
        'app/chatbot/conversation/ConversationController.*',
        'app/chatbot/conversation/ConversationService.*',
        'app/chatbot/responses/ResponseStreamService.*'
]

jacocoTestReport {
    dependsOn(tasks.named('test'))
    reports {
        xml.required = true
        html.required = true
    }
    classDirectories.setFrom(
            files(classDirectories.files.collect {
                fileTree(dir: it, include: coverageIncludes)
            })
    )
}

jacocoTestCoverageVerification {
    dependsOn(tasks.named('test'))
    violationRules {
        rule {
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.90
            }
        }
    }
    classDirectories.setFrom(
            files(classDirectories.files.collect {
                fileTree(dir: it, include: coverageIncludes)
            })
    )
}

tasks.named('check') {
    dependsOn(tasks.named('jacocoTestCoverageVerification'))
}

// Docker configuration
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.DockerRemoveImage

task buildDockerImage(type: DockerBuildImage) {
    group = 'docker'
    description = 'Builds Docker image for Spring Boot backend'
    
    dependsOn bootJar
    
    inputDir = file('.')
    images.add("${project.group}/chatbot-backend:${project.version}")
    images.add("${project.group}/chatbot-backend:latest")
    
    doFirst {
        println "Building Docker image: ${project.group}/chatbot-backend:${project.version}"
    }
}

task pushDockerImage(type: DockerPushImage) {
    group = 'docker'
    description = 'Pushes Docker image to registry'
    
    dependsOn buildDockerImage
    images.add("${project.group}/chatbot-backend:${project.version}")
    images.add("${project.group}/chatbot-backend:latest")
}

task removeDockerImage(type: DockerRemoveImage) {
    group = 'docker'
    description = 'Removes local Docker image'
    
    targetImageId "${project.group}/chatbot-backend:${project.version}"
}

// Spring Boot Docker support (alternative using built-in Spring Boot plugin)
bootBuildImage {
    imageName = "${project.group}/chatbot-backend:${project.version}"
    environment = [
        'BP_JVM_VERSION': '17'
    ]
    
    docker {
        publishRegistry {
            // Configure registry credentials if needed
            // username = project.findProperty('docker.registry.username') ?: ''
            // password = project.findProperty('docker.registry.password') ?: ''
        }
    }
}
