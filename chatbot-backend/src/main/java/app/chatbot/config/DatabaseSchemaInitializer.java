package app.chatbot.config;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.r2dbc.core.DatabaseClient;
import org.springframework.stereotype.Component;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Component
public class DatabaseSchemaInitializer implements ApplicationRunner {

    private static final Logger log = LoggerFactory.getLogger(DatabaseSchemaInitializer.class);

    private static final List<String> DDL = List.of(
            """
            CREATE TABLE IF NOT EXISTS conversations (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                title VARCHAR(255),
                created_at TIMESTAMP WITH TIME ZONE NOT NULL,
                updated_at TIMESTAMP WITH TIME ZONE NOT NULL
            )
            """,
            """
            CREATE TABLE IF NOT EXISTS messages (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                conversation_id BIGINT NOT NULL,
                role VARCHAR(20) NOT NULL,
                content CLOB,
                raw_json CLOB,
                output_index INT,
                item_id VARCHAR(96),
                created_at TIMESTAMP WITH TIME ZONE NOT NULL,
                CONSTRAINT fk_messages_conversation
                    FOREIGN KEY (conversation_id) REFERENCES conversations(id)
                    ON DELETE CASCADE
            )
            """,
            """
            CREATE INDEX IF NOT EXISTS idx_messages_conversation ON messages(conversation_id, created_at)
            """,
            """
            CREATE TABLE IF NOT EXISTS tool_calls (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                conversation_id BIGINT NOT NULL,
                type VARCHAR(20) NOT NULL,
                name VARCHAR(255),
                call_id VARCHAR(120),
                arguments_json CLOB,
                result_json CLOB,
                status VARCHAR(20) NOT NULL,
                output_index INT,
                item_id VARCHAR(96),
                created_at TIMESTAMP WITH TIME ZONE NOT NULL,
                CONSTRAINT fk_tool_calls_conversation
                    FOREIGN KEY (conversation_id) REFERENCES conversations(id)
                    ON DELETE CASCADE
            )
            """,
            """
            CREATE INDEX IF NOT EXISTS idx_tool_calls_conversation ON tool_calls(conversation_id, created_at)
            """,
            """
            CREATE INDEX IF NOT EXISTS idx_tool_calls_lookup ON tool_calls(conversation_id, output_index, type)
            """
    );

    private final DatabaseClient databaseClient;

    public DatabaseSchemaInitializer(DatabaseClient databaseClient) {
        this.databaseClient = databaseClient;
    }

    @Override
    public void run(ApplicationArguments args) {
        Flux.fromIterable(DDL)
                .concatMap(sql -> executeStatement(sql).thenReturn(sql))
                .doOnNext(sql -> log.debug("Executed DDL {}", sql.replaceAll("\\s+", " ").trim()))
                .doOnError(error -> log.error("Failed to initialize schema", error))
                .then()
                .block();
    }

    private Mono<Void> executeStatement(String sql) {
        return databaseClient.sql(sql)
                .fetch()
                .rowsUpdated()
                .onErrorResume(throwable -> {
                    log.warn("Schema init statement failed: {}", throwable.getMessage());
                    return Mono.empty();
                })
                .then();
    }
}
